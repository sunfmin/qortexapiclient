// Generated by github.com/hypermusk/hypermusk
// DO NOT EDIT
package client

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"errors"
	"github.com/theplant/govalidations"
	"github.com/theplant/qortexapi"
	"io"
	"log"
	"net/http"
	"runtime/debug"
)

var ApiDomain string

func ToJson(v interface{}) (r []byte) {
	r, _ = json.Marshal(v)
	return
}

func printStackAndError(err error) {
	log.Printf("********** Debug Error message: %+v ***********\n", err)
	debug.PrintStack()
}

type SerializableError struct {
	Message string
	Code    string
	Reason  govalidations.Validated
}

func (this *SerializableError) toError() (err error) {

	if this == nil {
		return
	}

	err = this.Reason.ToError()
	if err == nil && this.Message != "" {
		err = errors.New(this.Message)
	}

	return
}

type AuthAdminService struct {
	Session string
}

type authAdminService_GetAccessRequests_Results struct {
	AccessReqs []*qortexapi.AccessReq
	Err        SerializableError
}

func (this *AuthAdminService) GetAccessRequests() (accessReqs []*qortexapi.AccessReq, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/GetAccessRequests.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_GetAccessRequests_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	accessReqs = result.AccessReqs

	err = result.Err.toError()

	return
}

type authAdminService_ExportAllUsers_Results struct {
	MemberInfos []*qortexapi.MailChimpUserListItem
	Err         SerializableError
}

func (this *AuthAdminService) ExportAllUsers() (memberInfos []*qortexapi.MailChimpUserListItem, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/ExportAllUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_ExportAllUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	memberInfos = result.MemberInfos

	err = result.Err.toError()

	return
}

type authAdminService_ExportChineseUsers_Results struct {
	MemberInfos []*qortexapi.MailChimpUserListItem
	Err         SerializableError
}

func (this *AuthAdminService) ExportChineseUsers() (memberInfos []*qortexapi.MailChimpUserListItem, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/ExportChineseUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_ExportChineseUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	memberInfos = result.MemberInfos

	err = result.Err.toError()

	return
}

type authAdminService_ExportEnglishUsers_Results struct {
	MemberInfos []*qortexapi.MailChimpUserListItem
	Err         SerializableError
}

func (this *AuthAdminService) ExportEnglishUsers() (memberInfos []*qortexapi.MailChimpUserListItem, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/ExportEnglishUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_ExportEnglishUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	memberInfos = result.MemberInfos

	err = result.Err.toError()

	return
}

type authAdminService_ExportJapaneseUsers_Results struct {
	MemberInfos []*qortexapi.MailChimpUserListItem
	Err         SerializableError
}

func (this *AuthAdminService) ExportJapaneseUsers() (memberInfos []*qortexapi.MailChimpUserListItem, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/ExportJapaneseUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_ExportJapaneseUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	memberInfos = result.MemberInfos

	err = result.Err.toError()

	return
}

type authAdminService_ChangeMemberEmail_Results struct {
	Err SerializableError
}

func (this *AuthAdminService) ChangeMemberEmail(input *qortexapi.ChangeEmailInput) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/ChangeMemberEmail.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_ChangeMemberEmail_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authAdminService_GetTotalOnlineUsers_Results struct {
	EmbedUsers []*qortexapi.EmbedUser
	Err        SerializableError
}

func (this *AuthAdminService) GetTotalOnlineUsers() (embedUsers []*qortexapi.EmbedUser, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/GetTotalOnlineUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_GetTotalOnlineUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	embedUsers = result.EmbedUsers

	err = result.Err.toError()

	return
}

type authAdminService_MarkOrgFreeOrPay_Results struct {
	Free bool
	Err  SerializableError
}

func (this *AuthAdminService) MarkOrgFreeOrPay(orgId string) (free bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/MarkOrgFreeOrPay.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_MarkOrgFreeOrPay_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	free = result.Free

	err = result.Err.toError()

	return
}

type authAdminService_GetOrgPayment_Results struct {
	OrgPaymentInfos []*qortexapi.OrgPaymentInfo
	Err             SerializableError
}

func (this *AuthAdminService) GetOrgPayment() (orgPaymentInfos []*qortexapi.OrgPaymentInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/GetOrgPayment.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_GetOrgPayment_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	orgPaymentInfos = result.OrgPaymentInfos

	err = result.Err.toError()

	return
}

type authAdminService_GetPaymentHistory_Results struct {
	History []qortexapi.OrgPaymentHistory
	Err     SerializableError
}

func (this *AuthAdminService) GetPaymentHistory(orgId string) (history []qortexapi.OrgPaymentHistory, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/GetPaymentHistory.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_GetPaymentHistory_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	history = result.History

	err = result.Err.toError()

	return
}

type authAdminService_SetTrial_Results struct {
	Err SerializableError
}

func (this *AuthAdminService) SetTrial(orgId string, deadLine string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	paramsMap["DeadLine"] = deadLine
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/SetTrial.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_SetTrial_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authAdminService_SetExpiredAt_Results struct {
	Err SerializableError
}

func (this *AuthAdminService) SetExpiredAt(orgId string, deadLine string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	paramsMap["DeadLine"] = deadLine
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/SetExpiredAt.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_SetExpiredAt_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authAdminService_SendPaymentWarnEmail_Results struct {
	Err SerializableError
}

func (this *AuthAdminService) SendPaymentWarnEmail(orgId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/SendPaymentWarnEmail.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_SendPaymentWarnEmail_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authAdminService_GetMinOrgs_Results struct {
	OrgInfos []*qortexapi.MinOrgInfo
	Err      SerializableError
}

func (this *AuthAdminService) GetMinOrgs() (orgInfos []*qortexapi.MinOrgInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/GetMinOrgs.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_GetMinOrgs_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	orgInfos = result.OrgInfos

	err = result.Err.toError()

	return
}

type authAdminService_GetOrgUserCache_Results struct {
	OrgUserCache *qortexapi.OrgUserCache
	Err          SerializableError
}

func (this *AuthAdminService) GetOrgUserCache(orgId string) (orgUserCache *qortexapi.OrgUserCache, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/GetOrgUserCache.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_GetOrgUserCache_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	orgUserCache = result.OrgUserCache

	err = result.Err.toError()

	return
}

type authAdminService_ResetOrgUserCache_Results struct {
	Err SerializableError
}

func (this *AuthAdminService) ResetOrgUserCache(orgId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/ResetOrgUserCache.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_ResetOrgUserCache_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authAdminService_SetFreeUserLimit_Results struct {
	Err SerializableError
}

func (this *AuthAdminService) SetFreeUserLimit(orgId string, num int) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	paramsMap["Num"] = num
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/SetFreeUserLimit.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_SetFreeUserLimit_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authAdminService_ResetCount_Results struct {
	Err SerializableError
}

func (this *AuthAdminService) ResetCount(orgId string, groupId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthAdminService/ResetCount.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authAdminService_ResetCount_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type AuthMemberService struct{}

var DefaultAuthMemberService = &AuthMemberService{}

type authMemberService_GetNewOrganization_Results struct {
	Org *qortexapi.Organization
	Err SerializableError
}

func (this *AuthMemberService) GetNewOrganization(memberId string) (org *qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["MemberId"] = memberId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthMemberService/GetNewOrganization.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authMemberService_GetNewOrganization_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	org = result.Org

	err = result.Err.toError()

	return
}

type authMemberService_GetMyOrganizations_Results struct {
	Orgs []*qortexapi.Organization
	Err  SerializableError
}

func (this *AuthMemberService) GetMyOrganizations() (orgs []*qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthMemberService/GetMyOrganizations.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authMemberService_GetMyOrganizations_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	orgs = result.Orgs

	err = result.Err.toError()

	return
}

type authMemberService_CreateOrganization_Results struct {
	ApiOrg *qortexapi.Organization
	Err    SerializableError
}

func (this *AuthMemberService) CreateOrganization(input *qortexapi.OrganizationInput) (apiOrg *qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthMemberService/CreateOrganization.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authMemberService_CreateOrganization_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	apiOrg = result.ApiOrg

	err = result.Err.toError()

	return
}

type authMemberService_JoinOrganization_Results struct {
	Err SerializableError
}

func (this *AuthMemberService) JoinOrganization(orgId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthMemberService/JoinOrganization.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authMemberService_JoinOrganization_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authMemberService_LeaveOrganization_Results struct {
	Err SerializableError
}

func (this *AuthMemberService) LeaveOrganization(orgId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthMemberService/LeaveOrganization.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authMemberService_LeaveOrganization_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authMemberService_SwitchOrganization_Results struct {
	Err SerializableError
}

func (this *AuthMemberService) SwitchOrganization(orgId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthMemberService/SwitchOrganization.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authMemberService_SwitchOrganization_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authMemberService_GetAbandonInfo_Results struct {
	Info *qortexapi.AbandonInfo
	Err  SerializableError
}

func (this *AuthMemberService) GetAbandonInfo(abandonOrgId string, memberId string) (info *qortexapi.AbandonInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["AbandonOrgId"] = abandonOrgId
	paramsMap["MemberId"] = memberId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthMemberService/GetAbandonInfo.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authMemberService_GetAbandonInfo_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	info = result.Info

	err = result.Err.toError()

	return
}

type authMemberService_GetShareRequest_Results struct {
	ShareRequest *qortexapi.ShareRequest
	Err          SerializableError
}

func (this *AuthMemberService) GetShareRequest(token string) (shareRequest *qortexapi.ShareRequest, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthMemberService/GetShareRequest.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authMemberService_GetShareRequest_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	shareRequest = result.ShareRequest

	err = result.Err.toError()

	return
}

type authMemberService_RejectShareRequestByInvitee_Results struct {
	Err SerializableError
}

func (this *AuthMemberService) RejectShareRequestByInvitee(token string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthMemberService/RejectShareRequestByInvitee.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authMemberService_RejectShareRequestByInvitee_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authMemberService_AcceptShareRequestByInvitee_Results struct {
	Err SerializableError
}

func (this *AuthMemberService) AcceptShareRequestByInvitee(token string, toOrgId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	paramsMap["ToOrgId"] = toOrgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthMemberService/AcceptShareRequestByInvitee.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authMemberService_AcceptShareRequestByInvitee_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type AuthUserService struct {
	Session string
	OrgId   string
}

type authUserService_GetNewEntry_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) GetNewEntry(groupId string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetNewEntry.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetNewEntry_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_GetNewChatEntry_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) GetNewChatEntry(input *qortexapi.NewChatInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetNewChatEntry.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetNewChatEntry_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_GetQortexSupportEntries_Results struct {
	Entries []*qortexapi.Entry
	Err     SerializableError
}

func (this *AuthUserService) GetQortexSupportEntries(before string, limit int, withComments bool) (entries []*qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	paramsMap["WithComments"] = withComments
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetQortexSupportEntries.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetQortexSupportEntries_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entries = result.Entries

	err = result.Err.toError()

	return
}

type authUserService_CreateEntry_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) CreateEntry(input *qortexapi.EntryInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CreateEntry.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CreateEntry_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_CreateTask_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) CreateTask(input *qortexapi.EntryInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CreateTask.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CreateTask_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_CloseTask_Results struct {
	Entry *qortexapi.Task
	Err   SerializableError
}

func (this *AuthUserService) CloseTask(entryId string, groupId string, taskId string) (entry *qortexapi.Task, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["TaskId"] = taskId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CloseTask.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CloseTask_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_UpdateTask_Results struct {
	Task *qortexapi.Task
	Err  SerializableError
}

func (this *AuthUserService) UpdateTask(taskInput *qortexapi.TaskInput) (task *qortexapi.Task, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["TaskInput"] = taskInput
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateTask.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateTask_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	task = result.Task

	err = result.Err.toError()

	return
}

type authUserService_CreateComment_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) CreateComment(input *qortexapi.EntryInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CreateComment.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CreateComment_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_GetComment_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) GetComment(entryId string, groupId string, languageCode string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetComment.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetComment_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_EditComment_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) EditComment(entryId string, groupId string, languageCode string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/EditComment.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_EditComment_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_UpdateComment_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) UpdateComment(input *qortexapi.EntryInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateComment.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateComment_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_UpdateEntry_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) UpdateEntry(input *qortexapi.EntryInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateEntry.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateEntry_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_UpdateKnowledgebase_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UpdateKnowledgebase(groupId string, entryId string, knowledgebase bool) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["EntryId"] = entryId
	paramsMap["Knowledgebase"] = knowledgebase
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateKnowledgebase.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateKnowledgebase_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetLatestUpdatedEntryIdByTitle_Results struct {
	EntryId string
	Err     SerializableError
}

func (this *AuthUserService) GetLatestUpdatedEntryIdByTitle(title string, groupId string) (entryId string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Title"] = title
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetLatestUpdatedEntryIdByTitle.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetLatestUpdatedEntryIdByTitle_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entryId = result.EntryId

	err = result.Err.toError()

	return
}

type authUserService_GetTitle_Results struct {
	Title string
	Err   SerializableError
}

func (this *AuthUserService) GetTitle(groupId string, entryId string) (title string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["EntryId"] = entryId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetTitle.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetTitle_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	title = result.Title

	err = result.Err.toError()

	return
}

type authUserService_GetEntry_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) GetEntry(entryId string, groupId string, updateAtUnixNanoForVersion string, hightlightKeywords string, languageCode string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["UpdateAtUnixNanoForVersion"] = updateAtUnixNanoForVersion
	paramsMap["HightlightKeywords"] = hightlightKeywords
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetEntry.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetEntry_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_SwitchEntryVersion_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) SwitchEntryVersion(entryId string, groupId string, updateAtUnixNanoForVersion string, hightlightKeywords string, languageCode string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["UpdateAtUnixNanoForVersion"] = updateAtUnixNanoForVersion
	paramsMap["HightlightKeywords"] = hightlightKeywords
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SwitchEntryVersion.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SwitchEntryVersion_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_EditEntry_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) EditEntry(entryId string, groupId string, updateAtUnixNanoForVersion string, hightlightKeywords string, languageCode string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["UpdateAtUnixNanoForVersion"] = updateAtUnixNanoForVersion
	paramsMap["HightlightKeywords"] = hightlightKeywords
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/EditEntry.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_EditEntry_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_EditTranslation_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) EditTranslation(entryId string, groupId string, updateAtUnixNanoForVersion string, hightlightKeywords string, editingLanguageCode string, comparingLanguageCode string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["UpdateAtUnixNanoForVersion"] = updateAtUnixNanoForVersion
	paramsMap["HightlightKeywords"] = hightlightKeywords
	paramsMap["EditingLanguageCode"] = editingLanguageCode
	paramsMap["ComparingLanguageCode"] = comparingLanguageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/EditTranslation.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_EditTranslation_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_SwitchEntryLanguage_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) SwitchEntryLanguage(entryId string, groupId string, languageCode string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SwitchEntryLanguage.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SwitchEntryLanguage_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_GetKnowledgeOverview_Results struct {
	R   *qortexapi.KnowledgeOverview
	Err SerializableError
}

func (this *AuthUserService) GetKnowledgeOverview(groupId string, languageCode string) (r *qortexapi.KnowledgeOverview, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetKnowledgeOverview.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetKnowledgeOverview_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	r = result.R

	err = result.Err.toError()

	return
}

type authUserService_SwitchKnowledgeOverviewVersion_Results struct {
	R   *qortexapi.KnowledgeOverview
	Err SerializableError
}

func (this *AuthUserService) SwitchKnowledgeOverviewVersion(groupId string, entryId string, languageCode string) (r *qortexapi.KnowledgeOverview, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["EntryId"] = entryId
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SwitchKnowledgeOverviewVersion.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SwitchKnowledgeOverviewVersion_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	r = result.R

	err = result.Err.toError()

	return
}

type authUserService_UpdateKnowledgeOverview_Results struct {
	R   *qortexapi.KnowledgeOverview
	Err SerializableError
}

func (this *AuthUserService) UpdateKnowledgeOverview(input *qortexapi.KnowledgeOverviewInput) (r *qortexapi.KnowledgeOverview, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateKnowledgeOverview.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateKnowledgeOverview_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	r = result.R

	err = result.Err.toError()

	return
}

type authUserService_GetEntryToTranslate_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) GetEntryToTranslate(entryId string, groupId string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetEntryToTranslate.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetEntryToTranslate_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_GetWikiSectionToTranslate_Results struct {
	Entry *qortexapi.KnowledgeOverview
	Err   SerializableError
}

func (this *AuthUserService) GetWikiSectionToTranslate(entryId string, groupId string) (entry *qortexapi.KnowledgeOverview, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetWikiSectionToTranslate.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetWikiSectionToTranslate_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_DeleteEntry_Results struct {
	DelType string
	Err     SerializableError
}

func (this *AuthUserService) DeleteEntry(entryId string, groupId string, dType string) (delType string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["DType"] = dType
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DeleteEntry.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DeleteEntry_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	delType = result.DelType

	err = result.Err.toError()

	return
}

type authUserService_DeleteEntryTranslation_Results struct {
	DelType string
	Err     SerializableError
}

func (this *AuthUserService) DeleteEntryTranslation(entryId string, groupId string, languageCode string) (delType string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DeleteEntryTranslation.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DeleteEntryTranslation_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	delType = result.DelType

	err = result.Err.toError()

	return
}

type authUserService_MuteEntry_Results struct {
	Err SerializableError
}

func (this *AuthUserService) MuteEntry(entryId string, groupId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/MuteEntry.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_MuteEntry_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_UndoMuteEntry_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UndoMuteEntry(entryId string, groupId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UndoMuteEntry.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UndoMuteEntry_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetMachineTranslatableLangauges_Results struct {
	Options *qortexapi.LanguageSelector
	Err     SerializableError
}

func (this *AuthUserService) GetMachineTranslatableLangauges() (options *qortexapi.LanguageSelector, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMachineTranslatableLangauges.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMachineTranslatableLangauges_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	options = result.Options

	err = result.Err.toError()

	return
}

type authUserService_SingleEntryMachineTranslate_Results struct {
	TranslatedThread *qortexapi.TranslatedThread
	Err              SerializableError
}

func (this *AuthUserService) SingleEntryMachineTranslate(entryId string, groupId string, currentLang string, targetlang string, isMarkdown bool) (translatedThread *qortexapi.TranslatedThread, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["CurrentLang"] = currentLang
	paramsMap["Targetlang"] = targetlang
	paramsMap["IsMarkdown"] = isMarkdown
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SingleEntryMachineTranslate.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SingleEntryMachineTranslate_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	translatedThread = result.TranslatedThread

	err = result.Err.toError()

	return
}

type authUserService_MachineTranslate_Results struct {
	TranslatedThread *qortexapi.TranslatedThread
	Err              SerializableError
}

func (this *AuthUserService) MachineTranslate(entryId string, groupId string, currentLang string, targetlang string) (translatedThread *qortexapi.TranslatedThread, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["CurrentLang"] = currentLang
	paramsMap["Targetlang"] = targetlang
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/MachineTranslate.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_MachineTranslate_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	translatedThread = result.TranslatedThread

	err = result.Err.toError()

	return
}

type authUserService_SingleWikiSectionMachineTranslate_Results struct {
	TranslatedThread *qortexapi.TranslatedThread
	Err              SerializableError
}

func (this *AuthUserService) SingleWikiSectionMachineTranslate(entryId string, groupId string, currentLang string, targetlang string, isMarkdown bool) (translatedThread *qortexapi.TranslatedThread, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["CurrentLang"] = currentLang
	paramsMap["Targetlang"] = targetlang
	paramsMap["IsMarkdown"] = isMarkdown
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SingleWikiSectionMachineTranslate.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SingleWikiSectionMachineTranslate_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	translatedThread = result.TranslatedThread

	err = result.Err.toError()

	return
}

type authUserService_MachineTranslateWikiSection_Results struct {
	TranslatedThread *qortexapi.TranslatedThread
	Err              SerializableError
}

func (this *AuthUserService) MachineTranslateWikiSection(entryId string, groupId string, targetlang string) (translatedThread *qortexapi.TranslatedThread, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["Targetlang"] = targetlang
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/MachineTranslateWikiSection.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_MachineTranslateWikiSection_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	translatedThread = result.TranslatedThread

	err = result.Err.toError()

	return
}

type authUserService_OriginalThread_Results struct {
	TranslatedThread *qortexapi.TranslatedThread
	Err              SerializableError
}

func (this *AuthUserService) OriginalThread(entryId string, groupId string) (translatedThread *qortexapi.TranslatedThread, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/OriginalThread.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_OriginalThread_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	translatedThread = result.TranslatedThread

	err = result.Err.toError()

	return
}

type authUserService_GetEntryAttachments_Results struct {
	Attachments []*qortexapi.Attachment
	Err         SerializableError
}

func (this *AuthUserService) GetEntryAttachments(entryId string, groupId string) (attachments []*qortexapi.Attachment, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetEntryAttachments.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetEntryAttachments_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	attachments = result.Attachments

	err = result.Err.toError()

	return
}

type authUserService_GetDocViewSession_Results struct {
	SessionId string
	Err       SerializableError
}

func (this *AuthUserService) GetDocViewSession(doi string, groupId string, attachmentId string) (sessionId string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Doi"] = doi
	paramsMap["GroupId"] = groupId
	paramsMap["AttachmentId"] = attachmentId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetDocViewSession.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetDocViewSession_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	sessionId = result.SessionId

	err = result.Err.toError()

	return
}

type authUserService_GetOtherVersionsComments_Results struct {
	Comments []*qortexapi.Entry
	Err      SerializableError
}

func (this *AuthUserService) GetOtherVersionsComments(entryId string, groupId string, updateAtUnixNanoForVersion string) (comments []*qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["UpdateAtUnixNanoForVersion"] = updateAtUnixNanoForVersion
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOtherVersionsComments.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOtherVersionsComments_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	comments = result.Comments

	err = result.Err.toError()

	return
}

type authUserService_GetOtherVersionsTaskLogs_Results struct {
	TaskLogs []*qortexapi.TaskLog
	Err      SerializableError
}

func (this *AuthUserService) GetOtherVersionsTaskLogs(entryId string, groupId string, updateAtUnixNanoForVersion string) (taskLogs []*qortexapi.TaskLog, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["UpdateAtUnixNanoForVersion"] = updateAtUnixNanoForVersion
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOtherVersionsTaskLogs.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOtherVersionsTaskLogs_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	taskLogs = result.TaskLogs

	err = result.Err.toError()

	return
}

type authUserService_GetGroupEntries_Results struct {
	Entries []*qortexapi.Entry
	Err     SerializableError
}

func (this *AuthUserService) GetGroupEntries(groupId string, entryType string, before string, limit int, withComments bool) (entries []*qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["EntryType"] = entryType
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	paramsMap["WithComments"] = withComments
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroupEntries.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroupEntries_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entries = result.Entries

	err = result.Err.toError()

	return
}

type authUserService_GetMyFeedEntries_Results struct {
	Entries []*qortexapi.Entry
	Err     SerializableError
}

func (this *AuthUserService) GetMyFeedEntries(entryType string, before string, limit int, withComments bool) (entries []*qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryType"] = entryType
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	paramsMap["WithComments"] = withComments
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyFeedEntries.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyFeedEntries_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entries = result.Entries

	err = result.Err.toError()

	return
}

type authUserService_GetMyFeedEntriesV2_Results struct {
	Entries []*qortexapi.Entry
	Err     SerializableError
}

func (this *AuthUserService) GetMyFeedEntriesV2(before string, limit int, withComments bool, directAtMe bool) (entries []*qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	paramsMap["WithComments"] = withComments
	paramsMap["DirectAtMe"] = directAtMe
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyFeedEntriesV2.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyFeedEntriesV2_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entries = result.Entries

	err = result.Err.toError()

	return
}

type authUserService_GetGroupAside_Results struct {
	Ga  *qortexapi.GroupAside
	Err SerializableError
}

func (this *AuthUserService) GetGroupAside() (ga *qortexapi.GroupAside, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroupAside.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroupAside_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	ga = result.Ga

	err = result.Err.toError()

	return
}

type authUserService_GetNewGroupAside_Results struct {
	Nga *qortexapi.NewGroupAside
	Err SerializableError
}

func (this *AuthUserService) GetNewGroupAside() (nga *qortexapi.NewGroupAside, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetNewGroupAside.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetNewGroupAside_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	nga = result.Nga

	err = result.Err.toError()

	return
}

type authUserService_GetGroupAsideV2_Results struct {
	Ga  *qortexapi.NewGroupAside
	Err SerializableError
}

func (this *AuthUserService) GetGroupAsideV2() (ga *qortexapi.NewGroupAside, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroupAsideV2.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroupAsideV2_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	ga = result.Ga

	err = result.Err.toError()

	return
}

type authUserService_GetMyFeedEntriesLite_Results struct {
	Entries []*qortexapi.Entry
	Err     SerializableError
}

func (this *AuthUserService) GetMyFeedEntriesLite(before string, limit int) (entries []*qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyFeedEntriesLite.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyFeedEntriesLite_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entries = result.Entries

	err = result.Err.toError()

	return
}

type authUserService_GetNewFeedEntries_Results struct {
	Entries []*qortexapi.Entry
	Err     SerializableError
}

func (this *AuthUserService) GetNewFeedEntries(entryType string, fromTimeUnixNano string, limit int) (entries []*qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryType"] = entryType
	paramsMap["FromTimeUnixNano"] = fromTimeUnixNano
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetNewFeedEntries.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetNewFeedEntries_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entries = result.Entries

	err = result.Err.toError()

	return
}

type authUserService_GetUserEntries_Results struct {
	Entries []*qortexapi.Entry
	Err     SerializableError
}

func (this *AuthUserService) GetUserEntries(userId string, entryType string, before string, limit int) (entries []*qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	paramsMap["EntryType"] = entryType
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetUserEntries.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetUserEntries_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entries = result.Entries

	err = result.Err.toError()

	return
}

type authUserService_GetUserEntriesV2_Results struct {
	Entries []*qortexapi.Entry
	Err     SerializableError
}

func (this *AuthUserService) GetUserEntriesV2(input *qortexapi.UserEntriesInput) (entries []*qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetUserEntriesV2.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetUserEntriesV2_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entries = result.Entries

	err = result.Err.toError()

	return
}

type authUserService_GetMyNotifications_Results struct {
	Mynotis *qortexapi.MyNotifications
	Err     SerializableError
}

func (this *AuthUserService) GetMyNotifications(before string, limit int) (mynotis *qortexapi.MyNotifications, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyNotifications.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyNotifications_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	mynotis = result.Mynotis

	err = result.Err.toError()

	return
}

type authUserService_GetMyNotificationItems_Results struct {
	NotificationItems []*qortexapi.NotificationItem
	Err               SerializableError
}

func (this *AuthUserService) GetMyNotificationItems(before string, limit int) (notificationItems []*qortexapi.NotificationItem, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyNotificationItems.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyNotificationItems_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	notificationItems = result.NotificationItems

	err = result.Err.toError()

	return
}

type authUserService_MarkAllAsRead_Results struct {
	Mycount *qortexapi.MyCount
	Err     SerializableError
}

func (this *AuthUserService) MarkAllAsRead(groupId string) (mycount *qortexapi.MyCount, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/MarkAllAsRead.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_MarkAllAsRead_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	mycount = result.Mycount

	err = result.Err.toError()

	return
}

type authUserService_GetWatchList_Results struct {
	Watchlist *qortexapi.WatchList
	Err       SerializableError
}

func (this *AuthUserService) GetWatchList(before string, limit int) (watchlist *qortexapi.WatchList, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetWatchList.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetWatchList_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	watchlist = result.Watchlist

	err = result.Err.toError()

	return
}

type authUserService_AddToWatchList_Results struct {
	Err SerializableError
}

func (this *AuthUserService) AddToWatchList(entryId string, groupId string, remindMode string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	paramsMap["RemindMode"] = remindMode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AddToWatchList.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AddToWatchList_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_StopWatching_Results struct {
	Err SerializableError
}

func (this *AuthUserService) StopWatching(entryId string, groupId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/StopWatching.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_StopWatching_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_RemindMe_Results struct {
	Reminded bool
	Err      SerializableError
}

func (this *AuthUserService) RemindMe() (reminded bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/RemindMe.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_RemindMe_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	reminded = result.Reminded

	err = result.Err.toError()

	return
}

type authUserService_StartSmartReminding_Results struct {
	Stopped bool
	Err     SerializableError
}

func (this *AuthUserService) StartSmartReminding(groupId string, watchItemId string) (stopped bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["WatchItemId"] = watchItemId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/StartSmartReminding.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_StartSmartReminding_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	stopped = result.Stopped

	err = result.Err.toError()

	return
}

type authUserService_StopReminding_Results struct {
	Stopped bool
	Err     SerializableError
}

func (this *AuthUserService) StopReminding(groupId string, watchItemId string) (stopped bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["WatchItemId"] = watchItemId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/StopReminding.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_StopReminding_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	stopped = result.Stopped

	err = result.Err.toError()

	return
}

type authUserService_UpdateLike_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) UpdateLike(input *qortexapi.LikeInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateLike.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateLike_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_CreateDraft_Results struct {
	Draft *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) CreateDraft(input *qortexapi.DraftInput) (draft *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CreateDraft.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CreateDraft_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	draft = result.Draft

	err = result.Err.toError()

	return
}

type authUserService_GetDraftList_Results struct {
	Draftlist *qortexapi.DraftList
	Err       SerializableError
}

func (this *AuthUserService) GetDraftList(before string, limit int) (draftlist *qortexapi.DraftList, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetDraftList.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetDraftList_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	draftlist = result.Draftlist

	err = result.Err.toError()

	return
}

type authUserService_GetDraft_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) GetDraft(entryId string, groupId string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetDraft.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetDraft_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_DeleteDraft_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DeleteDraft(entryId string, groupId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DeleteDraft.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DeleteDraft_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_ChooseMarkdownEditor_Results struct {
	Err SerializableError
}

func (this *AuthUserService) ChooseMarkdownEditor() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ChooseMarkdownEditor.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ChooseMarkdownEditor_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_ChooseStyledEditor_Results struct {
	Err SerializableError
}

func (this *AuthUserService) ChooseStyledEditor() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ChooseStyledEditor.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ChooseStyledEditor_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetNewGroup_Results struct {
	Group *qortexapi.Group
	Err   SerializableError
}

func (this *AuthUserService) GetNewGroup() (group *qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetNewGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetNewGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	group = result.Group

	err = result.Err.toError()

	return
}

type authUserService_GetGroup_Results struct {
	Group *qortexapi.Group
	Err   SerializableError
}

func (this *AuthUserService) GetGroup(groupId string) (group *qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	group = result.Group

	err = result.Err.toError()

	return
}

type authUserService_CreateGroup_Results struct {
	Group *qortexapi.Group
	Err   SerializableError
}

func (this *AuthUserService) CreateGroup(input *qortexapi.GroupInput) (group *qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CreateGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CreateGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	group = result.Group

	err = result.Err.toError()

	return
}

type authUserService_UpdateGroup_Results struct {
	Group *qortexapi.Group
	Err   SerializableError
}

func (this *AuthUserService) UpdateGroup(input *qortexapi.GroupInput) (group *qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	group = result.Group

	err = result.Err.toError()

	return
}

type authUserService_UpdateGroupLogo_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UpdateGroupLogo(groupId string, logoURL string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["LogoURL"] = logoURL
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateGroupLogo.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateGroupLogo_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_DeleteGroup_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DeleteGroup(groupId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DeleteGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DeleteGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetGroupBySlug_Results struct {
	Group *qortexapi.Group
	Err   SerializableError
}

func (this *AuthUserService) GetGroupBySlug(slug string) (group *qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Slug"] = slug
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroupBySlug.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroupBySlug_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	group = result.Group

	err = result.Err.toError()

	return
}

type authUserService_GetGroups_Results struct {
	Groups []*qortexapi.Group
	Err    SerializableError
}

func (this *AuthUserService) GetGroups(keyword string) (groups []*qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Keyword"] = keyword
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroups.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroups_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	groups = result.Groups

	err = result.Err.toError()

	return
}

type authUserService_GetEmbedGroups_Results struct {
	Groups []*qortexapi.EmbedGroup
	Err    SerializableError
}

func (this *AuthUserService) GetEmbedGroups(keyword string) (groups []*qortexapi.EmbedGroup, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Keyword"] = keyword
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetEmbedGroups.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetEmbedGroups_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	groups = result.Groups

	err = result.Err.toError()

	return
}

type authUserService_GetPublicGroups_Results struct {
	Groups []*qortexapi.Group
	Err    SerializableError
}

func (this *AuthUserService) GetPublicGroups(keyword string) (groups []*qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Keyword"] = keyword
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetPublicGroups.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetPublicGroups_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	groups = result.Groups

	err = result.Err.toError()

	return
}

type authUserService_AddUserToGroup_Results struct {
	Err SerializableError
}

func (this *AuthUserService) AddUserToGroup(groupId string, userId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AddUserToGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AddUserToGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_RemoveUserFromGroup_Results struct {
	Err SerializableError
}

func (this *AuthUserService) RemoveUserFromGroup(groupId string, userId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/RemoveUserFromGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_RemoveUserFromGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetClassifiedGroups_Results struct {
	AnouncementGroup       *qortexapi.Group
	SmGroup                *qortexapi.Group
	FollowedNormalGroups   []*qortexapi.Group
	FollowedSharedGroups   []*qortexapi.Group
	UnFollowedNormalGroups []*qortexapi.Group
	UnFollowedSharedGroups []*qortexapi.Group
	Err                    SerializableError
}

func (this *AuthUserService) GetClassifiedGroups() (anouncementGroup *qortexapi.Group, smGroup *qortexapi.Group, followedNormalGroups []*qortexapi.Group, followedSharedGroups []*qortexapi.Group, unFollowedNormalGroups []*qortexapi.Group, unFollowedSharedGroups []*qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetClassifiedGroups.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetClassifiedGroups_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	anouncementGroup = result.AnouncementGroup

	smGroup = result.SmGroup

	followedNormalGroups = result.FollowedNormalGroups

	followedSharedGroups = result.FollowedSharedGroups

	unFollowedNormalGroups = result.UnFollowedNormalGroups

	unFollowedSharedGroups = result.UnFollowedSharedGroups

	err = result.Err.toError()

	return
}

type authUserService_GetAllGroupCollections_Results struct {
	Gcs []*qortexapi.GroupCollection
	Err SerializableError
}

func (this *AuthUserService) GetAllGroupCollections() (gcs []*qortexapi.GroupCollection, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetAllGroupCollections.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetAllGroupCollections_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	gcs = result.Gcs

	err = result.Err.toError()

	return
}

type authUserService_ToggleGroupArchiving_Results struct {
	Err SerializableError
}

func (this *AuthUserService) ToggleGroupArchiving(gids string, signal bool) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Gids"] = gids
	paramsMap["Signal"] = signal
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ToggleGroupArchiving.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ToggleGroupArchiving_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_BulkUpdateTasksInGroup_Results struct {
	Err SerializableError
}

func (this *AuthUserService) BulkUpdateTasksInGroup(groupId string, taskPwMap []*qortexapi.TaskPwMap, taskInputs []*qortexapi.TaskInput, markerInputs []*qortexapi.ToDoMarkerInput) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["TaskPwMap"] = taskPwMap
	paramsMap["TaskInputs"] = taskInputs
	paramsMap["MarkerInputs"] = markerInputs
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/BulkUpdateTasksInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_BulkUpdateTasksInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_UpdateCollection_Results struct {
	Group *qortexapi.Group
	Err   SerializableError
}

func (this *AuthUserService) UpdateCollection(gId string, colId string, colName string) (group *qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GId"] = gId
	paramsMap["ColId"] = colId
	paramsMap["ColName"] = colName
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateCollection.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateCollection_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	group = result.Group

	err = result.Err.toError()

	return
}

type authUserService_GetAllGroupUsers_Results struct {
	Uers []qortexapi.User
	Err  SerializableError
}

func (this *AuthUserService) GetAllGroupUsers(groupId string) (uers []qortexapi.User, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetAllGroupUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetAllGroupUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	uers = result.Uers

	err = result.Err.toError()

	return
}

type authUserService_GetGroupFiles_Results struct {
	Files []*qortexapi.File
	Err   SerializableError
}

func (this *AuthUserService) GetGroupFiles(groupId string, before string, limit int) (files []*qortexapi.File, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroupFiles.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroupFiles_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	files = result.Files

	err = result.Err.toError()

	return
}

type authUserService_GetAuthUser_Results struct {
	User *qortexapi.User
	Err  SerializableError
}

func (this *AuthUserService) GetAuthUser() (user *qortexapi.User, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetAuthUser.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetAuthUser_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	user = result.User

	err = result.Err.toError()

	return
}

type authUserService_GetOrgUsers_Results struct {
	Users        []qortexapi.User
	NextFullName string
	Err          SerializableError
}

func (this *AuthUserService) GetOrgUsers(keyword string, startFullName string, limit int) (users []qortexapi.User, nextFullName string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Keyword"] = keyword
	paramsMap["StartFullName"] = startFullName
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOrgUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOrgUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	users = result.Users

	nextFullName = result.NextFullName

	err = result.Err.toError()

	return
}

type authUserService_GetOrgAllUsers_Results struct {
	Users []qortexapi.User
	Err   SerializableError
}

func (this *AuthUserService) GetOrgAllUsers() (users []qortexapi.User, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOrgAllUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOrgAllUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	users = result.Users

	err = result.Err.toError()

	return
}

type authUserService_GetGroupUsers_Results struct {
	Users        []qortexapi.User
	NextFullName string
	Err          SerializableError
}

func (this *AuthUserService) GetGroupUsers(groupId string, keyword string, onlyFollowers bool, startFullName string, limit int) (users []qortexapi.User, nextFullName string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["Keyword"] = keyword
	paramsMap["OnlyFollowers"] = onlyFollowers
	paramsMap["StartFullName"] = startFullName
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroupUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroupUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	users = result.Users

	nextFullName = result.NextFullName

	err = result.Err.toError()

	return
}

type authUserService_GetUser_Results struct {
	User *qortexapi.User
	Err  SerializableError
}

func (this *AuthUserService) GetUser(userId string) (user *qortexapi.User, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetUser.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetUser_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	user = result.User

	err = result.Err.toError()

	return
}

type authUserService_EnableUser_Results struct {
	Err SerializableError
}

func (this *AuthUserService) EnableUser(userId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/EnableUser.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_EnableUser_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_DisableUser_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DisableUser(userId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DisableUser.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DisableUser_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_DeleteUser_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DeleteUser(userId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DeleteUser.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DeleteUser_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_PromoteToSuperUser_Results struct {
	Err SerializableError
}

func (this *AuthUserService) PromoteToSuperUser(userId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/PromoteToSuperUser.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_PromoteToSuperUser_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_DemoteFromSuperUser_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DemoteFromSuperUser(userId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DemoteFromSuperUser.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DemoteFromSuperUser_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_FollowUser_Results struct {
	Err SerializableError
}

func (this *AuthUserService) FollowUser(userId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/FollowUser.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_FollowUser_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_UnfollowUser_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UnfollowUser(userId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UnfollowUser.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UnfollowUser_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetMyFollowingUsers_Results struct {
	FollowingUsers []qortexapi.User
	Err            SerializableError
}

func (this *AuthUserService) GetMyFollowingUsers() (followingUsers []qortexapi.User, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyFollowingUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyFollowingUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	followingUsers = result.FollowingUsers

	err = result.Err.toError()

	return
}

type authUserService_GetPanelStatus_Results struct {
	PanelStatus *qortexapi.PanelStatus
	Err         SerializableError
}

func (this *AuthUserService) GetPanelStatus() (panelStatus *qortexapi.PanelStatus, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetPanelStatus.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetPanelStatus_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	panelStatus = result.PanelStatus

	err = result.Err.toError()

	return
}

type authUserService_GetUserPreferences_Results struct {
	Preferences *qortexapi.Preferences
	Err         SerializableError
}

func (this *AuthUserService) GetUserPreferences() (preferences *qortexapi.Preferences, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetUserPreferences.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetUserPreferences_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	preferences = result.Preferences

	err = result.Err.toError()

	return
}

type authUserService_UpdateUserPreferences_Results struct {
	Preferences *qortexapi.Preferences
	Err         SerializableError
}

func (this *AuthUserService) UpdateUserPreferences(input *qortexapi.PreferencesInput) (preferences *qortexapi.Preferences, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateUserPreferences.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateUserPreferences_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	preferences = result.Preferences

	err = result.Err.toError()

	return
}

type authUserService_GetOrgEmbedUsers_Results struct {
	Users []*qortexapi.EmbedUser
	Err   SerializableError
}

func (this *AuthUserService) GetOrgEmbedUsers() (users []*qortexapi.EmbedUser, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOrgEmbedUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOrgEmbedUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	users = result.Users

	err = result.Err.toError()

	return
}

type authUserService_GetSharedAndPrivateGroupUsers_Results struct {
	GroupUsers []*qortexapi.GroupUsers
	Err        SerializableError
}

func (this *AuthUserService) GetSharedAndPrivateGroupUsers() (groupUsers []*qortexapi.GroupUsers, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetSharedAndPrivateGroupUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetSharedAndPrivateGroupUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	groupUsers = result.GroupUsers

	err = result.Err.toError()

	return
}

type authUserService_GetAllUsers_Results struct {
	CurrentOrgUsers []*qortexapi.EmbedUser
	GroupUsers      []*qortexapi.GroupUsers
	Err             SerializableError
}

func (this *AuthUserService) GetAllUsers() (currentOrgUsers []*qortexapi.EmbedUser, groupUsers []*qortexapi.GroupUsers, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetAllUsers.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetAllUsers_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	currentOrgUsers = result.CurrentOrgUsers

	groupUsers = result.GroupUsers

	err = result.Err.toError()

	return
}

type authUserService_UpdateUserProfile_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UpdateUserProfile(input *qortexapi.UserProfileInput) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateUserProfile.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateUserProfile_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_SetPreferredLanguages_Results struct {
	Err SerializableError
}

func (this *AuthUserService) SetPreferredLanguages(languageCodes []string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["LanguageCodes"] = languageCodes
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SetPreferredLanguages.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SetPreferredLanguages_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_ToggleGroupCol_Results struct {
	Err SerializableError
}

func (this *AuthUserService) ToggleGroupCol(gtype int, colIdStr string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Gtype"] = gtype
	paramsMap["ColIdStr"] = colIdStr
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ToggleGroupCol.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ToggleGroupCol_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetMyCount_Results struct {
	MyCount *qortexapi.MyCount
	Err     SerializableError
}

func (this *AuthUserService) GetMyCount() (myCount *qortexapi.MyCount, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyCount.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyCount_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	myCount = result.MyCount

	err = result.Err.toError()

	return
}

type authUserService_ReadEntry_Results struct {
	MyCount *qortexapi.MyCount
	Err     SerializableError
}

func (this *AuthUserService) ReadEntry(entryId string, groupId string) (myCount *qortexapi.MyCount, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ReadEntry.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ReadEntry_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	myCount = result.MyCount

	err = result.Err.toError()

	return
}

type authUserService_ReadNotificationItem_Results struct {
	MyCount *qortexapi.MyCount
	Err     SerializableError
}

func (this *AuthUserService) ReadNotificationItem(itemId string, groupId string) (myCount *qortexapi.MyCount, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["ItemId"] = itemId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ReadNotificationItem.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ReadNotificationItem_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	myCount = result.MyCount

	err = result.Err.toError()

	return
}

type authUserService_GetJoinOrgInvitations_Results struct {
	Invitations []*qortexapi.Invitation
	Err         SerializableError
}

func (this *AuthUserService) GetJoinOrgInvitations() (invitations []*qortexapi.Invitation, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetJoinOrgInvitations.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetJoinOrgInvitations_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	invitations = result.Invitations

	err = result.Err.toError()

	return
}

type authUserService_GetOrganization_Results struct {
	Org *qortexapi.Organization
	Err SerializableError
}

func (this *AuthUserService) GetOrganization(orgId string) (org *qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOrganization.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOrganization_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	org = result.Org

	err = result.Err.toError()

	return
}

type authUserService_GetOrganizations_Results struct {
	Orgs []*qortexapi.Organization
	Err  SerializableError
}

func (this *AuthUserService) GetOrganizations(orgIds []string) (orgs []*qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgIds"] = orgIds
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOrganizations.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOrganizations_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	orgs = result.Orgs

	err = result.Err.toError()

	return
}

type authUserService_GetMyOrgsUnreadInfo_Results struct {
	UnreadInfo []*qortexapi.OrgUnreadInfo
	Err        SerializableError
}

func (this *AuthUserService) GetMyOrgsUnreadInfo() (unreadInfo []*qortexapi.OrgUnreadInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyOrgsUnreadInfo.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyOrgsUnreadInfo_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	unreadInfo = result.UnreadInfo

	err = result.Err.toError()

	return
}

type authUserService_GetMyJoinedOrganizations_Results struct {
	Orgs []*qortexapi.Organization
	Err  SerializableError
}

func (this *AuthUserService) GetMyJoinedOrganizations() (orgs []*qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyJoinedOrganizations.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyJoinedOrganizations_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	orgs = result.Orgs

	err = result.Err.toError()

	return
}

type authUserService_GetCurrentOrganization_Results struct {
	Org *qortexapi.Organization
	Err SerializableError
}

func (this *AuthUserService) GetCurrentOrganization() (org *qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetCurrentOrganization.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetCurrentOrganization_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	org = result.Org

	err = result.Err.toError()

	return
}

type authUserService_SearchOrganizations_Results struct {
	Orgs []*qortexapi.SearchOrganization
	Err  SerializableError
}

func (this *AuthUserService) SearchOrganizations(keyword string) (orgs []*qortexapi.SearchOrganization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Keyword"] = keyword
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SearchOrganizations.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SearchOrganizations_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	orgs = result.Orgs

	err = result.Err.toError()

	return
}

type authUserService_UpdateOrganization_Results struct {
	Org *qortexapi.Organization
	Err SerializableError
}

func (this *AuthUserService) UpdateOrganization(input *qortexapi.OrganizationInput) (org *qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateOrganization.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateOrganization_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	org = result.Org

	err = result.Err.toError()

	return
}

type authUserService_SwitchOrganization_Results struct {
	Err SerializableError
}

func (this *AuthUserService) SwitchOrganization(orgId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SwitchOrganization.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SwitchOrganization_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_MarkAsSampleOrg_Results struct {
	Err SerializableError
}

func (this *AuthUserService) MarkAsSampleOrg() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/MarkAsSampleOrg.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_MarkAsSampleOrg_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_MarkAsStandardOrg_Results struct {
	Err SerializableError
}

func (this *AuthUserService) MarkAsStandardOrg() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/MarkAsStandardOrg.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_MarkAsStandardOrg_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetSampleOrgs_Results struct {
	Orgs []*qortexapi.Organization
	Err  SerializableError
}

func (this *AuthUserService) GetSampleOrgs() (orgs []*qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetSampleOrgs.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetSampleOrgs_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	orgs = result.Orgs

	err = result.Err.toError()

	return
}

type authUserService_GetSandboxOrgs_Results struct {
	Orgs []*qortexapi.Organization
	Err  SerializableError
}

func (this *AuthUserService) GetSandboxOrgs() (orgs []*qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetSandboxOrgs.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetSandboxOrgs_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	orgs = result.Orgs

	err = result.Err.toError()

	return
}

type authUserService_DeleteSandboxOrg_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DeleteSandboxOrg(orgId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgId"] = orgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DeleteSandboxOrg.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DeleteSandboxOrg_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_DeleteAllSandboxOrg_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DeleteAllSandboxOrg() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DeleteAllSandboxOrg.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DeleteAllSandboxOrg_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_AcceptShareRequestByAdmin_Results struct {
	Err SerializableError
}

func (this *AuthUserService) AcceptShareRequestByAdmin(requestId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["RequestId"] = requestId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AcceptShareRequestByAdmin.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AcceptShareRequestByAdmin_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_RejectShareRequestByAdmin_Results struct {
	Err SerializableError
}

func (this *AuthUserService) RejectShareRequestByAdmin(requestId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["RequestId"] = requestId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/RejectShareRequestByAdmin.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_RejectShareRequestByAdmin_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_StartTrial_Results struct {
	Err SerializableError
}

func (this *AuthUserService) StartTrial() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/StartTrial.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_StartTrial_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetOrgSettings_Results struct {
	OrgSetting *qortexapi.OrgSettings
	Err        SerializableError
}

func (this *AuthUserService) GetOrgSettings() (orgSetting *qortexapi.OrgSettings, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOrgSettings.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOrgSettings_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	orgSetting = result.OrgSetting

	err = result.Err.toError()

	return
}

type authUserService_UpdateOrgSettings_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UpdateOrgSettings(orgSettingInput *qortexapi.OrgSettingsInput) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgSettingInput"] = orgSettingInput
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateOrgSettings.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateOrgSettings_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_UpdateOrgResctriction_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UpdateOrgResctriction(orgSettingInput *qortexapi.OrganizationInput) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrgSettingInput"] = orgSettingInput
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateOrgResctriction.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateOrgResctriction_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_CanCreateGroup_Results struct {
	Ok  bool
	Err SerializableError
}

func (this *AuthUserService) CanCreateGroup() (ok bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CanCreateGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CanCreateGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	ok = result.Ok

	err = result.Err.toError()

	return
}

type authUserService_CanInvitePeople_Results struct {
	Ok  bool
	Err SerializableError
}

func (this *AuthUserService) CanInvitePeople() (ok bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CanInvitePeople.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CanInvitePeople_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	ok = result.Ok

	err = result.Err.toError()

	return
}

type authUserService_InvitePeople_Results struct {
	SendedEmails []string
	Err          SerializableError
}

func (this *AuthUserService) InvitePeople(emails []string, allowEmpty bool, skipInvalidEmail bool, customMessage string, toFollowGroups []string) (sendedEmails []string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Emails"] = emails
	paramsMap["AllowEmpty"] = allowEmpty
	paramsMap["SkipInvalidEmail"] = skipInvalidEmail
	paramsMap["CustomMessage"] = customMessage
	paramsMap["ToFollowGroups"] = toFollowGroups
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/InvitePeople.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_InvitePeople_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	sendedEmails = result.SendedEmails

	err = result.Err.toError()

	return
}

type authUserService_CancelInvitation_Results struct {
	Err SerializableError
}

func (this *AuthUserService) CancelInvitation(email string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Email"] = email
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CancelInvitation.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CancelInvitation_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_ResendInvitation_Results struct {
	Err SerializableError
}

func (this *AuthUserService) ResendInvitation(email string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Email"] = email
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ResendInvitation.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ResendInvitation_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_UpdateGroupAdvancedToDoSettings_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UpdateGroupAdvancedToDoSettings(groupId string, input *qortexapi.AdvancedToDoSettingsInput) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateGroupAdvancedToDoSettings.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateGroupAdvancedToDoSettings_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_UpdateNotificationsPreference_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UpdateNotificationsPreference(input *qortexapi.NotificationPreferenceInput) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateNotificationsPreference.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateNotificationsPreference_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_PrepareChangingEmail_Results struct {
	Changer *qortexapi.EmailChanger
	Err     SerializableError
}

func (this *AuthUserService) PrepareChangingEmail(newEmail string) (changer *qortexapi.EmailChanger, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["NewEmail"] = newEmail
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/PrepareChangingEmail.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_PrepareChangingEmail_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	changer = result.Changer

	err = result.Err.toError()

	return
}

type authUserService_ConfirmChangingEmail_Results struct {
	Err SerializableError
}

func (this *AuthUserService) ConfirmChangingEmail(token string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ConfirmChangingEmail.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ConfirmChangingEmail_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_UpdateAccount_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UpdateAccount(input *qortexapi.MemberAccountInput) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateAccount.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateAccount_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_SendShareRequest_Results struct {
	ShareRequest *qortexapi.ShareRequest
	Err          SerializableError
}

func (this *AuthUserService) SendShareRequest(groupId string, email string, message string) (shareRequest *qortexapi.ShareRequest, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["Email"] = email
	paramsMap["Message"] = message
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SendShareRequest.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SendShareRequest_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	shareRequest = result.ShareRequest

	err = result.Err.toError()

	return
}

type authUserService_SendShareRequestToOrg_Results struct {
	ShareRequest *qortexapi.ShareRequest
	Err          SerializableError
}

func (this *AuthUserService) SendShareRequestToOrg(groupId string, toOrgId string) (shareRequest *qortexapi.ShareRequest, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["ToOrgId"] = toOrgId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SendShareRequestToOrg.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SendShareRequestToOrg_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	shareRequest = result.ShareRequest

	err = result.Err.toError()

	return
}

type authUserService_GetShareRequests_Results struct {
	Sis []*qortexapi.ShareRequest
	Err SerializableError
}

func (this *AuthUserService) GetShareRequests(groupId string) (sis []*qortexapi.ShareRequest, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetShareRequests.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetShareRequests_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	sis = result.Sis

	err = result.Err.toError()

	return
}

type authUserService_CancelShareRequest_Results struct {
	Err SerializableError
}

func (this *AuthUserService) CancelShareRequest(requestId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["RequestId"] = requestId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CancelShareRequest.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CancelShareRequest_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_StopSharingGroup_Results struct {
	Err SerializableError
}

func (this *AuthUserService) StopSharingGroup(requestId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["RequestId"] = requestId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/StopSharingGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_StopSharingGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_DismissPresentationTip_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DismissPresentationTip() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DismissPresentationTip.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DismissPresentationTip_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_DismissTutorialsTip_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DismissTutorialsTip() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DismissTutorialsTip.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DismissTutorialsTip_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetMyChats_Results struct {
	Chats []*qortexapi.Chat
	Err   SerializableError
}

func (this *AuthUserService) GetMyChats() (chats []*qortexapi.Chat, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyChats.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyChats_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	chats = result.Chats

	err = result.Err.toError()

	return
}

type authUserService_GetMyChatWithUser_Results struct {
	Chat *qortexapi.Chat
	Err  SerializableError
}

func (this *AuthUserService) GetMyChatWithUser(userIdHex string) (chat *qortexapi.Chat, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserIdHex"] = userIdHex
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyChatWithUser.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyChatWithUser_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	chat = result.Chat

	err = result.Err.toError()

	return
}

type authUserService_GetChatHistory_Results struct {
	Convs   []*qortexapi.Conversation
	HasMore bool
	Err     SerializableError
}

func (this *AuthUserService) GetChatHistory(chatIdHex string, before string, limit int) (convs []*qortexapi.Conversation, hasMore bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["ChatIdHex"] = chatIdHex
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetChatHistory.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetChatHistory_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	convs = result.Convs

	hasMore = result.HasMore

	err = result.Err.toError()

	return
}

type authUserService_GetMyChatEntries_Results struct {
	Entries []*qortexapi.Entry
	Err     SerializableError
}

func (this *AuthUserService) GetMyChatEntries(before string, limit int) (entries []*qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetMyChatEntries.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetMyChatEntries_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entries = result.Entries

	err = result.Err.toError()

	return
}

type authUserService_CreateQortexSupport_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) CreateQortexSupport(input *qortexapi.QortexSupportInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CreateQortexSupport.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CreateQortexSupport_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_CreateQortexSupportComment_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) CreateQortexSupportComment(input *qortexapi.QortexSupportInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CreateQortexSupportComment.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CreateQortexSupportComment_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_GetQortexSupport_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) GetQortexSupport(entryId string, languageCode string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetQortexSupport.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetQortexSupport_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_EditQortexSupport_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) EditQortexSupport(entryId string, languageCode string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["LanguageCode"] = languageCode
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/EditQortexSupport.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_EditQortexSupport_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_GetQortexSupportComment_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) GetQortexSupportComment(entryId string) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetQortexSupportComment.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetQortexSupportComment_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_UpdateQortexSupport_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) UpdateQortexSupport(input *qortexapi.QortexSupportInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateQortexSupport.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateQortexSupport_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_UpdateQortexSupportComment_Results struct {
	Entry *qortexapi.Entry
	Err   SerializableError
}

func (this *AuthUserService) UpdateQortexSupportComment(input *qortexapi.QortexSupportInput) (entry *qortexapi.Entry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateQortexSupportComment.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateQortexSupportComment_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	entry = result.Entry

	err = result.Err.toError()

	return
}

type authUserService_GetQortexSupportHelpLink_Results struct {
	Link string
	Err  SerializableError
}

func (this *AuthUserService) GetQortexSupportHelpLink(title string) (link string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Title"] = title
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetQortexSupportHelpLink.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetQortexSupportHelpLink_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	link = result.Link

	err = result.Err.toError()

	return
}

type authUserService_SendQortexSupportTestingEmail_Results struct {
	Err SerializableError
}

func (this *AuthUserService) SendQortexSupportTestingEmail(entryId string, userId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["EntryId"] = entryId
	paramsMap["UserId"] = userId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SendQortexSupportTestingEmail.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SendQortexSupportTestingEmail_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_NewTask_Results struct {
	Task *qortexapi.Task
	Err  SerializableError
}

func (this *AuthUserService) NewTask(groupId string) (task *qortexapi.Task, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/NewTask.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_NewTask_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	task = result.Task

	err = result.Err.toError()

	return
}

type authUserService_EditTask_Results struct {
	Task *qortexapi.Task
	Err  SerializableError
}

func (this *AuthUserService) EditTask(groupId string, taskId string) (task *qortexapi.Task, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["TaskId"] = taskId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/EditTask.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_EditTask_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	task = result.Task

	err = result.Err.toError()

	return
}

type authUserService_ClaimTask_Results struct {
	Task *qortexapi.Task
	Err  SerializableError
}

func (this *AuthUserService) ClaimTask(taskId string, groupId string) (task *qortexapi.Task, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["TaskId"] = taskId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ClaimTask.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ClaimTask_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	task = result.Task

	err = result.Err.toError()

	return
}

type authUserService_UpdateSimpleTask_Results struct {
	Task *qortexapi.Task
	Err  SerializableError
}

func (this *AuthUserService) UpdateSimpleTask(input *qortexapi.TaskInput) (task *qortexapi.Task, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UpdateSimpleTask.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UpdateSimpleTask_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	task = result.Task

	err = result.Err.toError()

	return
}

type authUserService_GetTasksForMe_Results struct {
	NeedActionTasks []*qortexapi.TaskOutline
	GroupTasks      []*qortexapi.GroupTasksOutline
	Err             SerializableError
}

func (this *AuthUserService) GetTasksForMe() (needActionTasks []*qortexapi.TaskOutline, groupTasks []*qortexapi.GroupTasksOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetTasksForMe.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetTasksForMe_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	needActionTasks = result.NeedActionTasks

	groupTasks = result.GroupTasks

	err = result.Err.toError()

	return
}

type authUserService_GetOpenTasksIMade_Results struct {
	GroupTasks []*qortexapi.GroupTasksOutline
	Err        SerializableError
}

func (this *AuthUserService) GetOpenTasksIMade() (groupTasks []*qortexapi.GroupTasksOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOpenTasksIMade.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOpenTasksIMade_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	groupTasks = result.GroupTasks

	err = result.Err.toError()

	return
}

type authUserService_GetClosedTasksIMade_Results struct {
	Tasks []*qortexapi.TaskOutline
	Err   SerializableError
}

func (this *AuthUserService) GetClosedTasksIMade(before string, limit int) (tasks []*qortexapi.TaskOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetClosedTasksIMade.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetClosedTasksIMade_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	tasks = result.Tasks

	err = result.Err.toError()

	return
}

type authUserService_GetOpenTasksIWorkedOn_Results struct {
	GroupTasks []*qortexapi.GroupTasksOutline
	Err        SerializableError
}

func (this *AuthUserService) GetOpenTasksIWorkedOn() (groupTasks []*qortexapi.GroupTasksOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOpenTasksIWorkedOn.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOpenTasksIWorkedOn_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	groupTasks = result.GroupTasks

	err = result.Err.toError()

	return
}

type authUserService_GetClosedTasksIWorkedOn_Results struct {
	Tasks []*qortexapi.TaskOutline
	Err   SerializableError
}

func (this *AuthUserService) GetClosedTasksIWorkedOn(before string, limit int) (tasks []*qortexapi.TaskOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetClosedTasksIWorkedOn.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetClosedTasksIWorkedOn_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	tasks = result.Tasks

	err = result.Err.toError()

	return
}

type authUserService_GetTasksOutline_Results struct {
	NeedActionTasks []*qortexapi.TaskOutline
	GroupTasks      []*qortexapi.GroupTasksOutline
	Err             SerializableError
}

func (this *AuthUserService) GetTasksOutline(userId string, groupId string) (needActionTasks []*qortexapi.TaskOutline, groupTasks []*qortexapi.GroupTasksOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetTasksOutline.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetTasksOutline_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	needActionTasks = result.NeedActionTasks

	groupTasks = result.GroupTasks

	err = result.Err.toError()

	return
}

type authUserService_GetTasks_Results struct {
	GroupTasks []*qortexapi.GroupTasks
	Err        SerializableError
}

func (this *AuthUserService) GetTasks(userId string, groupId string) (groupTasks []*qortexapi.GroupTasks, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["UserId"] = userId
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetTasks.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetTasks_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	groupTasks = result.GroupTasks

	err = result.Err.toError()

	return
}

type authUserService_GetOpenTodos_Results struct {
	GroupTasks []*qortexapi.GroupTasksOutline
	Err        SerializableError
}

func (this *AuthUserService) GetOpenTodos(createByUid string, assignToUid string, sortBy string) (groupTasks []*qortexapi.GroupTasksOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["CreateByUid"] = createByUid
	paramsMap["AssignToUid"] = assignToUid
	paramsMap["SortBy"] = sortBy
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOpenTodos.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOpenTodos_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	groupTasks = result.GroupTasks

	err = result.Err.toError()

	return
}

type authUserService_GetCloseTodos_Results struct {
	Tasks []*qortexapi.TaskOutline
	Err   SerializableError
}

func (this *AuthUserService) GetCloseTodos(createByUid string, assignToUid string, before string, limit int) (tasks []*qortexapi.TaskOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["CreateByUid"] = createByUid
	paramsMap["AssignToUid"] = assignToUid
	paramsMap["Before"] = before
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetCloseTodos.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetCloseTodos_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	tasks = result.Tasks

	err = result.Err.toError()

	return
}

type authUserService_GetGroupGeneralSettingPage_Results struct {
	Page *qortexapi.GroupGeneralSettingPage
	Err  SerializableError
}

func (this *AuthUserService) GetGroupGeneralSettingPage(gId string) (page *qortexapi.GroupGeneralSettingPage, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GId"] = gId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroupGeneralSettingPage.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroupGeneralSettingPage_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	page = result.Page

	err = result.Err.toError()

	return
}

type authUserService_GetGroupUsersPage_Results struct {
	Page *qortexapi.GroupUsersPage
	Err  SerializableError
}

func (this *AuthUserService) GetGroupUsersPage(gId string) (page *qortexapi.GroupUsersPage, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GId"] = gId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroupUsersPage.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroupUsersPage_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	page = result.Page

	err = result.Err.toError()

	return
}

type authUserService_GetGroupSharingExternallyPage_Results struct {
	Page *qortexapi.GroupSharingExternallyPage
	Err  SerializableError
}

func (this *AuthUserService) GetGroupSharingExternallyPage(gId string) (page *qortexapi.GroupSharingExternallyPage, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GId"] = gId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroupSharingExternallyPage.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroupSharingExternallyPage_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	page = result.Page

	err = result.Err.toError()

	return
}

type authUserService_GetGroupAdvancedToDoSetting_Results struct {
	Page *qortexapi.GroupAdvancedSettingPage
	Err  SerializableError
}

func (this *AuthUserService) GetGroupAdvancedToDoSetting(gId string) (page *qortexapi.GroupAdvancedSettingPage, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GId"] = gId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetGroupAdvancedToDoSetting.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetGroupAdvancedToDoSetting_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	page = result.Page

	err = result.Err.toError()

	return
}

type authUserService_AllOpenAdvancedToDosInGroup_Results struct {
	Bucket *qortexapi.OpenAdvancedToDosBucket
	Err    SerializableError
}

func (this *AuthUserService) AllOpenAdvancedToDosInGroup(groupId string) (bucket *qortexapi.OpenAdvancedToDosBucket, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AllOpenAdvancedToDosInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AllOpenAdvancedToDosInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	bucket = result.Bucket

	err = result.Err.toError()

	return
}

type authUserService_AllOpenAdvancedToDosGroupingByUserInGroup_Results struct {
	Atos []*qortexapi.OpenAdvancedToDosPage
	Err  SerializableError
}

func (this *AuthUserService) AllOpenAdvancedToDosGroupingByUserInGroup(groupId string) (atos []*qortexapi.OpenAdvancedToDosPage, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AllOpenAdvancedToDosGroupingByUserInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AllOpenAdvancedToDosGroupingByUserInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	atos = result.Atos

	err = result.Err.toError()

	return
}

type authUserService_AllOpenAdvancedToDosGroupingByStatusInGroup_Results struct {
	Page     []*qortexapi.OpenAdvancedToDosBucket
	ApiGroup *qortexapi.Group
	Err      SerializableError
}

func (this *AuthUserService) AllOpenAdvancedToDosGroupingByStatusInGroup(groupId string) (page []*qortexapi.OpenAdvancedToDosBucket, apiGroup *qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AllOpenAdvancedToDosGroupingByStatusInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AllOpenAdvancedToDosGroupingByStatusInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	page = result.Page

	apiGroup = result.ApiGroup

	err = result.Err.toError()

	return
}

type authUserService_AllOpenAdvancedToDosGroupingByLabelInGroup_Results struct {
	Page     []*qortexapi.OpenAdvancedToDosBucket
	ApiGroup *qortexapi.Group
	Err      SerializableError
}

func (this *AuthUserService) AllOpenAdvancedToDosGroupingByLabelInGroup(groupId string) (page []*qortexapi.OpenAdvancedToDosBucket, apiGroup *qortexapi.Group, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AllOpenAdvancedToDosGroupingByLabelInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AllOpenAdvancedToDosGroupingByLabelInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	page = result.Page

	apiGroup = result.ApiGroup

	err = result.Err.toError()

	return
}

type authUserService_AllOpenBasicToDosInGroup_Results struct {
	TaskOutlines []*qortexapi.TaskOutline
	Err          SerializableError
}

func (this *AuthUserService) AllOpenBasicToDosInGroup(groupId string) (taskOutlines []*qortexapi.TaskOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AllOpenBasicToDosInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AllOpenBasicToDosInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	taskOutlines = result.TaskOutlines

	err = result.Err.toError()

	return
}

type authUserService_AllOpenBasicToDosGroupingByUserInGroup_Results struct {
	Atos []*qortexapi.BasicOpenToDoOutlines
	Err  SerializableError
}

func (this *AuthUserService) AllOpenBasicToDosGroupingByUserInGroup(groupId string) (atos []*qortexapi.BasicOpenToDoOutlines, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AllOpenBasicToDosGroupingByUserInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AllOpenBasicToDosGroupingByUserInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	atos = result.Atos

	err = result.Err.toError()

	return
}

type authUserService_AllClosedBasicToDosInGroup_Results struct {
	TaskOutlines []*qortexapi.TaskOutline
	Err          SerializableError
}

func (this *AuthUserService) AllClosedBasicToDosInGroup(groupId string, afterTimeS string) (taskOutlines []*qortexapi.TaskOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["AfterTimeS"] = afterTimeS
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AllClosedBasicToDosInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AllClosedBasicToDosInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	taskOutlines = result.TaskOutlines

	err = result.Err.toError()

	return
}

type authUserService_AllClosedAdvancedToDosInGroup_Results struct {
	ClosedOutlines []*qortexapi.ClosedAdvancedToDoOutline
	Err            SerializableError
}

func (this *AuthUserService) AllClosedAdvancedToDosInGroup(groupId string) (closedOutlines []*qortexapi.ClosedAdvancedToDoOutline, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/AllClosedAdvancedToDosInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_AllClosedAdvancedToDosInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	closedOutlines = result.ClosedOutlines

	err = result.Err.toError()

	return
}

type authUserService_MoreClosedAdvancedToDosWithStatusInGroup_Results struct {
	TaskOutlines []*qortexapi.TaskOutline
	ApiGroup     *qortexapi.Group
	HasMore      bool
	Err          SerializableError
}

func (this *AuthUserService) MoreClosedAdvancedToDosWithStatusInGroup(groupId string, status int, afterTime string) (taskOutlines []*qortexapi.TaskOutline, apiGroup *qortexapi.Group, hasMore bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["Status"] = status
	paramsMap["AfterTime"] = afterTime
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/MoreClosedAdvancedToDosWithStatusInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_MoreClosedAdvancedToDosWithStatusInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	taskOutlines = result.TaskOutlines

	apiGroup = result.ApiGroup

	hasMore = result.HasMore

	err = result.Err.toError()

	return
}

type authUserService_CountOfClosedToDosInGroup_Results struct {
	Count int
	Err   SerializableError
}

func (this *AuthUserService) CountOfClosedToDosInGroup(ttype int, groupId string) (count int, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Ttype"] = ttype
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CountOfClosedToDosInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CountOfClosedToDosInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	count = result.Count

	err = result.Err.toError()

	return
}

type authUserService_CountOfActionNeededToDosInGroup_Results struct {
	Count int
	Err   SerializableError
}

func (this *AuthUserService) CountOfActionNeededToDosInGroup(gid string) (count int, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Gid"] = gid
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CountOfActionNeededToDosInGroup.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CountOfActionNeededToDosInGroup_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	count = result.Count

	err = result.Err.toError()

	return
}

type authUserService_ToDoCSV_Results struct {
	Todos []*qortexapi.ToDoCSVItem
	Err   SerializableError
}

func (this *AuthUserService) ToDoCSV(groupId string, userId string, month string) (todos []*qortexapi.ToDoCSVItem, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["UserId"] = userId
	paramsMap["Month"] = month
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ToDoCSV.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ToDoCSV_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	todos = result.Todos

	err = result.Err.toError()

	return
}

type authUserService_RegisterAppleDevice_Results struct {
	Err SerializableError
}

func (this *AuthUserService) RegisterAppleDevice(token string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/RegisterAppleDevice.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_RegisterAppleDevice_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_UnregisterAppleDevice_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UnregisterAppleDevice(token string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UnregisterAppleDevice.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UnregisterAppleDevice_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_RegisterAndroidDevice_Results struct {
	Err SerializableError
}

func (this *AuthUserService) RegisterAndroidDevice(regid string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Regid"] = regid
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/RegisterAndroidDevice.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_RegisterAndroidDevice_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_UnregisterAndroidDevice_Results struct {
	Err SerializableError
}

func (this *AuthUserService) UnregisterAndroidDevice(regid string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Regid"] = regid
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/UnregisterAndroidDevice.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_UnregisterAndroidDevice_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetPaymentSession_Results struct {
	Session string
	Err     SerializableError
}

func (this *AuthUserService) GetPaymentSession() (session string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetPaymentSession.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetPaymentSession_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	session = result.Session

	err = result.Err.toError()

	return
}

type authUserService_CanSeeBilling_Results struct {
	Yes bool
	Err SerializableError
}

func (this *AuthUserService) CanSeeBilling() (yes bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CanSeeBilling.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CanSeeBilling_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	yes = result.Yes

	err = result.Err.toError()

	return
}

type authUserService_GetBillingInfo_Results struct {
	Billing *qortexapi.BillingInfo
	Err     SerializableError
}

func (this *AuthUserService) GetBillingInfo() (billing *qortexapi.BillingInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetBillingInfo.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetBillingInfo_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	billing = result.Billing

	err = result.Err.toError()

	return
}

type authUserService_GetReceiptInfo_Results struct {
	Receipt *qortexapi.ReceiptInfo
	Err     SerializableError
}

func (this *AuthUserService) GetReceiptInfo(id string) (receipt *qortexapi.ReceiptInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Id"] = id
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetReceiptInfo.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetReceiptInfo_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	receipt = result.Receipt

	err = result.Err.toError()

	return
}

type authUserService_SyncBilling_Results struct {
	Err SerializableError
}

func (this *AuthUserService) SyncBilling() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SyncBilling.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SyncBilling_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_SyncBillingDetails_Results struct {
	Err SerializableError
}

func (this *AuthUserService) SyncBillingDetails() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SyncBillingDetails.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SyncBillingDetails_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_ValidatePayment_Results struct {
	Err SerializableError
}

func (this *AuthUserService) ValidatePayment() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ValidatePayment.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ValidatePayment_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_CancelSubscription_Results struct {
	Err SerializableError
}

func (this *AuthUserService) CancelSubscription() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/CancelSubscription.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_CancelSubscription_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_DismissPaymentTips_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DismissPaymentTips() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DismissPaymentTips.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DismissPaymentTips_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_DisableProFeatrue_Results struct {
	R   bool
	Err SerializableError
}

func (this *AuthUserService) DisableProFeatrue(groupId string) (r bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DisableProFeatrue.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DisableProFeatrue_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	r = result.R

	err = result.Err.toError()

	return
}

type authUserService_GetContactUsInfo_Results struct {
	Info *qortexapi.ContactUsInfo
	Err  SerializableError
}

func (this *AuthUserService) GetContactUsInfo() (info *qortexapi.ContactUsInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetContactUsInfo.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetContactUsInfo_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	info = result.Info

	err = result.Err.toError()

	return
}

type authUserService_GetInitInfo_Results struct {
	Info *qortexapi.InitInfo
	Err  SerializableError
}

func (this *AuthUserService) GetInitInfo() (info *qortexapi.InitInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetInitInfo.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetInitInfo_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	info = result.Info

	err = result.Err.toError()

	return
}

type authUserService_GetNewInitInfo_Results struct {
	Info *qortexapi.InitInfo
	Err  SerializableError
}

func (this *AuthUserService) GetNewInitInfo() (info *qortexapi.InitInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetNewInitInfo.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetNewInitInfo_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	info = result.Info

	err = result.Err.toError()

	return
}

type authUserService_DeleteFile_Results struct {
	Attachments []*qortexapi.Attachment
	Err         SerializableError
}

func (this *AuthUserService) DeleteFile(groupId string, attachmentId string, ownerId string) (attachments []*qortexapi.Attachment, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["GroupId"] = groupId
	paramsMap["AttachmentId"] = attachmentId
	paramsMap["OwnerId"] = ownerId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DeleteFile.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DeleteFile_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	attachments = result.Attachments

	err = result.Err.toError()

	return
}

type authUserService_Search_Results struct {
	Sr  qortexapi.SearchResult
	Err SerializableError
}

func (this *AuthUserService) Search(sp qortexapi.SearchInput) (sr qortexapi.SearchResult, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Sp"] = sp
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/Search.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_Search_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	sr = result.Sr

	err = result.Err.toError()

	return
}

type authUserService_ValidateToken_Results struct {
	Err SerializableError
}

func (this *AuthUserService) ValidateToken() (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ValidateToken.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ValidateToken_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_SaveToken_Results struct {
	Token string
	Err   SerializableError
}

func (this *AuthUserService) SaveToken(tokenId string, label string, accessLevel int, forAllGroups bool, groupIds []string) (token string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["TokenId"] = tokenId
	paramsMap["Label"] = label
	paramsMap["AccessLevel"] = accessLevel
	paramsMap["ForAllGroups"] = forAllGroups
	paramsMap["GroupIds"] = groupIds
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/SaveToken.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_SaveToken_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	token = result.Token

	err = result.Err.toError()

	return
}

type authUserService_DeleteToken_Results struct {
	Err SerializableError
}

func (this *AuthUserService) DeleteToken(tokenId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["TokenId"] = tokenId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/DeleteToken.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_DeleteToken_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type authUserService_GetOrgTokens_Results struct {
	Tokens []*qortexapi.Token
	Err    SerializableError
}

func (this *AuthUserService) GetOrgTokens() (tokens []*qortexapi.Token, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/GetOrgTokens.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_GetOrgTokens_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	tokens = result.Tokens

	err = result.Err.toError()

	return
}

type authUserService_ZapierSubscribe_Results struct {
	WebhookId string
	Err       SerializableError
}

func (this *AuthUserService) ZapierSubscribe(input qortexapi.ZapierSubscribeInput) (webhookId string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ZapierSubscribe.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ZapierSubscribe_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	webhookId = result.WebhookId

	err = result.Err.toError()

	return
}

type authUserService_ZapierUnsubscribe_Results struct {
	Err SerializableError
}

func (this *AuthUserService) ZapierUnsubscribe(webhookId string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["WebhookId"] = webhookId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/AuthUserService/ZapierUnsubscribe.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result authUserService_ZapierUnsubscribe_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type PublicService struct{}

var DefaultPublicService = &PublicService{}

type publicService_GetSession_Results struct {
	Session string
	Err     SerializableError
}

func (this *PublicService) GetSession(email string, password string, locale string) (session string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Email"] = email
	paramsMap["Password"] = password
	paramsMap["Locale"] = locale
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/GetSession.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_GetSession_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	session = result.Session

	err = result.Err.toError()

	return
}

type publicService_GetSessionByToken_Results struct {
	Session string
	Err     SerializableError
}

func (this *PublicService) GetSessionByToken(token string, locale string) (session string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	paramsMap["Locale"] = locale
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/GetSessionByToken.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_GetSessionByToken_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	session = result.Session

	err = result.Err.toError()

	return
}

func (this *PublicService) GetAuthUserService(session string, orgId string) (authUserService qortexapi.AuthUserService, err error) {
	authUserService = &AuthUserService{
		Session: session,
		OrgId:   orgId,
	}
	return
}

type publicService_GetAuthorizedAdmin_Results struct {
	ApiEmbedUser qortexapi.EmbedUser
	Err          SerializableError
}

func (this *PublicService) GetAuthorizedAdmin(session string) (apiEmbedUser qortexapi.EmbedUser, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Session"] = session
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/GetAuthorizedAdmin.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_GetAuthorizedAdmin_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	apiEmbedUser = result.ApiEmbedUser

	err = result.Err.toError()

	return
}

func (this *PublicService) GetAuthAdminService(session string) (authAdminService qortexapi.AuthAdminService, err error) {
	authAdminService = &AuthAdminService{
		Session: session,
	}
	return
}

type publicService_ViaHTTPS_Results struct {
	Ok  bool
	Err SerializableError
}

func (this *PublicService) ViaHTTPS() (ok bool, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/ViaHTTPS.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_ViaHTTPS_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	ok = result.Ok

	err = result.Err.toError()

	return
}

type publicService_FindPassword_Results struct {
	Err SerializableError
}

func (this *PublicService) FindPassword(email string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Email"] = email
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/FindPassword.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_FindPassword_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type publicService_ResetPassword_Results struct {
	MemberId string
	Email    string
	Err      SerializableError
}

func (this *PublicService) ResetPassword(token string, password string, confirmedPassword string) (memberId string, email string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	paramsMap["Password"] = password
	paramsMap["ConfirmedPassword"] = confirmedPassword
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/ResetPassword.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_ResetPassword_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	memberId = result.MemberId

	email = result.Email

	err = result.Err.toError()

	return
}

type publicService_PrepareChangingEmail_Results struct {
	Changer *qortexapi.EmailChanger
	Err     SerializableError
}

func (this *PublicService) PrepareChangingEmail(memberId string, newEmail string, sharingToken string, invitationToken string) (changer *qortexapi.EmailChanger, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["MemberId"] = memberId
	paramsMap["NewEmail"] = newEmail
	paramsMap["SharingToken"] = sharingToken
	paramsMap["InvitationToken"] = invitationToken
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/PrepareChangingEmail.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_PrepareChangingEmail_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	changer = result.Changer

	err = result.Err.toError()

	return
}

type publicService_ConfirmChangingEmail_Results struct {
	ActivationToken string
	SharingToken    string
	InvitationToken string
	Err             SerializableError
}

func (this *PublicService) ConfirmChangingEmail(token string) (activationToken string, sharingToken string, invitationToken string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/ConfirmChangingEmail.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_ConfirmChangingEmail_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	activationToken = result.ActivationToken

	sharingToken = result.SharingToken

	invitationToken = result.InvitationToken

	err = result.Err.toError()

	return
}

type publicService_CancelChangingEmail_Results struct {
	Err SerializableError
}

func (this *PublicService) CancelChangingEmail(token string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/CancelChangingEmail.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_CancelChangingEmail_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type publicService_ChangeEmailToAcceptSharing_Results struct {
	Err SerializableError
}

func (this *PublicService) ChangeEmailToAcceptSharing(token string, newEmail string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	paramsMap["NewEmail"] = newEmail
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/ChangeEmailToAcceptSharing.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_ChangeEmailToAcceptSharing_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type publicService_GetShareRequest_Results struct {
	ShareRequest *qortexapi.ShareRequest
	Err          SerializableError
}

func (this *PublicService) GetShareRequest(token string, memberId string) (shareRequest *qortexapi.ShareRequest, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Token"] = token
	paramsMap["MemberId"] = memberId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/GetShareRequest.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_GetShareRequest_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	shareRequest = result.ShareRequest

	err = result.Err.toError()

	return
}

type publicService_ContactUs_Results struct {
	Contact *qortexapi.ContactInfo
	Err     SerializableError
}

func (this *PublicService) ContactUs(input *qortexapi.ContactInput) (contact *qortexapi.ContactInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/ContactUs.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_ContactUs_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	contact = result.Contact

	err = result.Err.toError()

	return
}

type publicService_GetBlogEntries_Results struct {
	Blog         *qortexapi.Blog
	BlogEntries  []*qortexapi.BlogEntry
	TotalPageNum int
	Err          SerializableError
}

func (this *PublicService) GetBlogEntries(doi string, pageNum int, limit int) (blog *qortexapi.Blog, blogEntries []*qortexapi.BlogEntry, totalPageNum int, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Doi"] = doi
	paramsMap["PageNum"] = pageNum
	paramsMap["Limit"] = limit
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/GetBlogEntries.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_GetBlogEntries_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	blog = result.Blog

	blogEntries = result.BlogEntries

	totalPageNum = result.TotalPageNum

	err = result.Err.toError()

	return
}

type publicService_GetBlogEntryBySlug_Results struct {
	Blog      *qortexapi.Blog
	BlogEntry *qortexapi.BlogEntry
	Err       SerializableError
}

func (this *PublicService) GetBlogEntryBySlug(doi string, slug string) (blog *qortexapi.Blog, blogEntry *qortexapi.BlogEntry, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Doi"] = doi
	paramsMap["Slug"] = slug
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/GetBlogEntryBySlug.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_GetBlogEntryBySlug_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	blog = result.Blog

	blogEntry = result.BlogEntry

	err = result.Err.toError()

	return
}

type publicService_GenerateBlogEntrySlug_Results struct {
	ValidSlug string
	Err       SerializableError
}

func (this *PublicService) GenerateBlogEntrySlug(doi string, slug string) (validSlug string, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Doi"] = doi
	paramsMap["Slug"] = slug
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/GenerateBlogEntrySlug.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_GenerateBlogEntrySlug_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	validSlug = result.ValidSlug

	err = result.Err.toError()

	return
}

type publicService_CreateNewsletter_Results struct {
	Newsletter *qortexapi.Newsletter
	Err        SerializableError
}

func (this *PublicService) CreateNewsletter(input *qortexapi.NewsletterInput) (newsletter *qortexapi.Newsletter, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Input"] = input
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/CreateNewsletter.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_CreateNewsletter_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	newsletter = result.Newsletter

	err = result.Err.toError()

	return
}

type publicService_InviteMe_Results struct {
	Err SerializableError
}

func (this *PublicService) InviteMe(organizationId string, email string) (err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["OrganizationId"] = organizationId
	paramsMap["Email"] = email
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/InviteMe.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_InviteMe_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	err = result.Err.toError()

	return
}

type publicService_CreateSandboxOrg_Results struct {
	R   *qortexapi.Organization
	Err SerializableError
}

func (this *PublicService) CreateSandboxOrg(idOrQortexURL string) (r *qortexapi.Organization, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["IdOrQortexURL"] = idOrQortexURL
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/CreateSandboxOrg.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_CreateSandboxOrg_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	r = result.R

	err = result.Err.toError()

	return
}

type publicService_CreateSandboxMember_Results struct {
	R   *qortexapi.Member
	Err SerializableError
}

func (this *PublicService) CreateSandboxMember(mi *qortexapi.MemberAccountInput) (r *qortexapi.Member, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["Mi"] = mi
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/CreateSandboxMember.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_CreateSandboxMember_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	r = result.R

	err = result.Err.toError()

	return
}

type publicService_GetPushInfo_Results struct {
	Info *qortexapi.PushInfo
	Err  SerializableError
}

func (this *PublicService) GetPushInfo(itemId string) (info *qortexapi.PushInfo, err error) {
	bodyMap := make(map[string]interface{})
	bodyMap["This"] = this
	paramsMap := make(map[string]interface{})
	paramsMap["ItemId"] = itemId
	bodyMap["Params"] = paramsMap

	client := new(http.Client)
	request, err := http.NewRequest("POST", ApiDomain+"/PublicService/GetPushInfo.json", bytes.NewReader(ToJson(bodyMap)))
	request.Header.Add("Accept-Encoding", "gzip")

	response, err := client.Do(request)
	if err != nil {
		printStackAndError(err)
		return
	}

	if response == nil || response.Body == nil {
		return
	}
	defer response.Body.Close()

	if response.StatusCode >= 300 {
		err = errors.New("request url: " + request.URL.String() + "status: " + response.Status)
		return
	}

	// Check that the server actually sent compressed data
	var reader io.ReadCloser
	switch response.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(response.Body)
	default:
		reader = response.Body
	}

	var result publicService_GetPushInfo_Results
	dec := json.NewDecoder(reader)
	if e := dec.Decode(&result); e != nil {
		printStackAndError(e)
		// No return
	}

	info = result.Info

	err = result.Err.toError()

	return
}
